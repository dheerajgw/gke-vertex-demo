name: Agentic-Heal

on:
  # Auto-trigger when CI completes; we only run if CI concluded 'failure' (see job.if)
  workflow_run:
    workflows: ["CI (main-only, self-heal)"]  # <-- must match your CI 'name:' exactly
    types: [completed]

  # Allow manual runs too (handy for testing)
  workflow_dispatch:

jobs:
  heal:
    # Run if: (manual) OR (triggered by CI run AND CI concluded failure)
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.workflow_run && github.event.workflow_run.conclusion == 'failure') }}
    runs-on: ubuntu-latest

    permissions:
      actions: read          # read CI artifacts
      contents: write        # push fix branch
      pull-requests: write   # open PR

    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_LOCATION:   ${{ secrets.GCP_LOCATION }}
      VERTEX_MODEL:   ${{ secrets.VERTEX_MODEL }}

    steps:
      # 1) Checkout the exact SHA that failed (workflow_run) or the current ref (manual)
      - name: Checkout failed commit (or current)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      # 2) Download CI junit artifact from the failed CI run (if workflow_run)
      - name: Download CI logs (from failed CI run)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        with:
          name: ci-logs                 # <-- must match CI upload name
          path: ./ci-logs
          run-id: ${{ github.event.workflow_run.id }}i
          repository: ${{ github.repository }}       # <—
          github-token: ${{ secrets.GITHUB_TOKEN }}  # <—
        continue-on-error: false
      
      # Debug: list artifacts on the failed CI run (helps if download fails)
      - name: Debug list artifacts on failed CI run
        if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'failure' }}
        uses: actions/github-script@v7
        with:
          script: |
            const runId = ${{ github.event.workflow_run.id }};
            const { owner, repo } = context.repo;
            const res = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id: runId });
            core.info(`Artifacts on CI run ${runId}:`);
            for (const a of res.data.artifacts) {
              core.info(`- ${a.name} (#${a.id}) size=${a.size_in_bytes} expired=${a.expired}`);
            }

      # Fallback (manual trigger): try to fetch latest artifact named ci-logs
      - name: Download CI logs (manual fallback)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        uses: actions/download-artifact@v4
        with:
          name: ci-logs
          path: ./ci-logs
          repository: ${{ github.repository }}       # <—
          github-token: ${{ secrets.GITHUB_TOKEN }}  # <—
        continue-on-error: true

      # 3) Auth to Google Cloud (sets GOOGLE_APPLICATION_CREDENTIALS automatically)
      - name: Auth to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      # (Optional) gcloud info, helpful when debugging credentials/project
      - name: Setup gcloud (debug only)
        uses: google-github-actions/setup-gcloud@v2

      - name: Show gcloud account/project (debug)
        run: |
          gcloud auth list || true
          gcloud config list || true

      # 4) Python & deps for healer
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps (Vertex SDK)
        run: python -m pip install -r agents/requirements.txt

      - name: Set bot identity env
        run: |
          echo "GH_BOT_ACTOR=agentic-bot" >> $GITHUB_ENV
          echo "GH_BOT_EMAIL=agentic-bot@example.com" >> $GITHUB_ENV

      # 5) Run your Vertex-powered healer (diff -> apply -> test -> push)
      - name: Run Agentic Healer (Vertex + fallbacks)
        run: |
          python agents/mcp_server.py

      # 6) Compute the fix branch as an output (simple, reusable)
      - name: Compute auto-fix branch
        id: af
        run: |
          # Read the branch name directly from git
          BRANCH="$(git rev-parse --abbrev-ref HEAD)"
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "Computed branch: ${BRANCH}"

      # 7) Open a PR to main if the branch exists (healer pushes only if tests pass)
      - name: Open PR to main (if branch exists)
        if: ${{ always() }}
        uses: actions/github-script@v7
        with:
          script: |
            const branch = `${{ steps.af.outputs.branch }}`;
            const { owner, repo } = context.repo;
            const base = 'main';

            // Check if branch exists in the repo (created/pushed by healer)
            try {
              await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
            } catch (e) {
              core.info(`Auto-fix branch not found (${branch}); skipping PR. Details: ${e.message}`);
              return;
            }

            // Avoid duplicate PRs
            const existing = await github.rest.pulls.list({
              owner, repo, head: `${owner}:${branch}`, base, state: 'open'
            });
            if (existing.data.length > 0) {
              core.info(`PR already exists: #${existing.data[0].number}`);
              return;
            }

            const title = `Agentic fix: auto-heal for ${branch}`;
            const body  = 'Opened automatically by Agentic-Heal after a CI failure. Includes changes that made tests pass in CI. Please review and merge.';

            const pr = await github.rest.pulls.create({ owner, repo, title, head: branch, base, body });
            core.info(`Opened PR #${pr.data.number} from ${branch} -> ${base}`);

